<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="EmptyReadOnly" xml:space="preserve">
    <value>Empty object {0} are read-only</value>
  </data>
  <data name="IsEmpty" xml:space="preserve">
    <value>In the domain design, all objects should not be null, the source of the error: {0}</value>
  </data>
  <data name="NoDataContext" xml:space="preserve">
    <value>There is no data context, please check whether it is in command mode or manually open the data context</value>
  </data>
  <data name="NoDefineEmpty" xml:space="preserve">
    <value>Type {0} does not define empty, we agree that each field type will have a static property of Empty, representing an empty object</value>
  </data>
  <data name="NoDefineLoadConstructParameter" xml:space="preserve">
    <value>Warehouse {0} does not define a static method for loading warehouse construct parameter {1}</value>
  </data>
  <data name="NoRepositoryConstructor" xml:space="preserve">
    <value>Type {0} is no definition of the repository constructor</value>
  </data>
  <data name="NotASCII" xml:space="preserve">
    <value>{0} not ascii</value>
  </data>
  <data name="NotDefinedObjectRepositoryAttribute" xml:space="preserve">
    <value>Type {0} does not define ObjectRepositoryAttribute</value>
  </data>
  <data name="BearNoValue" xml:space="preserve">
    <value>The value of BearValue can not be obtained because there is no value</value>
  </data>
  <data name="PropertyValueRepeated" xml:space="preserve">
    <value>The value of property {0} is repeated</value>
  </data>
  <data name="ReturnDataContextError" xml:space="preserve">
    <value>Exception in return data context, Borrowcount greater than 0</value>
  </data>
  <data name="SnapshotReadOnly" xml:space="preserve">
    <value>{0} object snapshots are read-only</value>
  </data>
  <data name="SnapshotTargetError" xml:space="preserve">
    <value>You can only create an object snapshot for AggregateRoot</value>
  </data>
  <data name="StringLengthLessThan" xml:space="preserve">
    <value>{0} length less than {1}</value>
  </data>
  <data name="StringLengthMoreThan" xml:space="preserve">
    <value>{0} length more than {1}</value>
  </data>
  <data name="ValueObjectReadOnly" xml:space="preserve">
    <value>ValueObject {0} is read-only</value>
  </data>
  <data name="IncorrectEmailFormat" xml:space="preserve">
    <value>The property {0} is incorrect for the email format</value>
  </data>
  <data name="IncorrectMobileNumberFormat" xml:space="preserve">
    <value>The property {0} is incorrect for the mobile number format</value>
  </data>
  <data name="ListCountLessThan" xml:space="preserve">
    <value>{0} count less than {1}</value>
  </data>
  <data name="ListCountMoreThan" xml:space="preserve">
    <value>{0} count more than {1}</value>
  </data>
  <data name="ListItemError" xml:space="preserve">
    <value>The list {0} validation error {1}</value>
  </data>
  <data name="PersistTargetTypeError" xml:space="preserve">
    <value>You can only persist IAggregateRoot or IEntityObjectPro objects</value>
  </data>
  <data name="GetUniqueKeyError" xml:space="preserve">
    <value>Unable to compute the unique key for type {0}, which must be IAggregateRoot or IEntityObjectPro</value>
  </data>
  <data name="RepeatedDeclareProperty" xml:space="preserve">
    <value>Type {0} repeatedly defined property {1}</value>
  </data>
  <data name="NotPropertyRepository" xml:space="preserve">
    <value>Type {0} property {1} does not mark PropertyRepository attribute, all domain properties should be able to be added to the warehouse</value>
  </data>
  <data name="DomainPropertyRemoved" xml:space="preserve">
    <value>Domain Property {0} has been removed</value>
  </data>
  <data name="ObjectExtensionAttributeFirstParamError" xml:space="preserve">
    <value>Type {0} error, the first argument to the ObjectExtensionAttribute must be a field object type or a domain object extension class</value>
  </data>
  <data name="PropertyActionObjectExtensionTypeError" xml:space="preserve">
    <value>Type {0} does not meet the requirements, static domain property action must be defined in the domain object extension class members</value>
  </data>
  <data name="PropertyActionObjectExtensionNoStatic" xml:space="preserve">
    <value>Method {0} does not meet the requirements, the domain property action must be static on the domain object extension class</value>
  </data>
  <data name="PropertyActionObjectTypeError" xml:space="preserve">
    <value>Type {0} does not meet the requirements, non-static domain property action must be defined in the domain object class members</value>
  </data>
  <data name="NeedTypeKey" xml:space="preserve">
    <value>The domain derived class {0} must specify a unique typeKey</value>
  </data>
  <data name="NotFoundDerivedType" xml:space="preserve">
    <value>Did not find {0} the domain derived class type</value>
  </data>
  <data name="NotFoundEmpty" xml:space="preserve">
    <value>Type {0} does not define Empty static property or does not assign value to Empty static property</value>
  </data>
  <data name="NoDefineMethodFromRepository" xml:space="preserve">
    <value>Repository {0} does not define method {1}</value>
  </data>
  <data name="MetadataCodeError" xml:space="preserve">
    <value>The metadata code for type {0} is different. In dynamic class, the metadataCode of the same type name is the same</value>
  </data>
  <data name="NoDyanmicTypeDefine" xml:space="preserve">
    <value>No dynamic type definition found for {0}</value>
  </data>
  <data name="UnrecognizedType" xml:space="preserve">
    <value>Unrecognized dynamic type {0}</value>
  </data>
  <data name="TypeDefineFindTypeError" xml:space="preserve">
    <value>Unknown type {0}</value>
  </data>
  <data name="ValueLessThan" xml:space="preserve">
    <value>{0} value less than {1}</value>
  </data>
  <data name="ValueMoreThan" xml:space="preserve">
    <value>{0} value more than {1}</value>
  </data>
  <data name="DynamicObjectLoadError" xml:space="preserve">
    <value>The dto data is malformed and does not match the definition {0}</value>
  </data>
  <data name="NotFoundRepository" xml:space="preserve">
    <value>Did not find the implementation of {0} repository</value>
  </data>
  <data name="NotFoundRemotable" xml:space="preserve">
    <value>Did not find the {0} {1} remotable definition</value>
  </data>
  <data name="NoDyanmicTypeDefineForRemoteType" xml:space="preserve">
    <value>Did not find the remote type {0} in the local dynamic type definition</value>
  </data>
  <data name="UninitializedDomainObject" xml:space="preserve">
    <value>Uninitialized domain object</value>
  </data>
  <data name="DynamicTypeRepeated" xml:space="preserve">
    <value>Defines multiple dynamic types with the name {0}</value>
  </data>
</root>